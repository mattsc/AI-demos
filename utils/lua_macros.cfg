# !!! Note: macros in this file are not necessairly exactly the same as
# !!! macros of the same name on the wiki page

#define COWARD ID RADIUS SEEK_X SEEK_Y AVOID_X AVOID_Y
    # Turns an existing unit into a coward
    [store_unit]
        [filter]
            id={ID}
        [/filter]
        variable=tmp_unit
    [/store_unit]
    [modify_ai]
        side=$tmp_unit.side
        action=add
        path=stage[main_loop].candidate_action[{ID}]
        [candidate_action]
            name=bca_coward_{ID}
            id=bca_coward_{ID}
            engine=lua
            sticky=yes
            unit_x=$tmp_unit.x
            unit_y=$tmp_unit.y
            evaluation="return (...):coward_eval('{ID}')"
            execution="(...):coward_exec('{ID}', {RADIUS}, '{SEEK_X}', '{SEEK_Y}', '{AVOID_X}', '{AVOID_Y}')"
        [/candidate_action]
    [/modify_ai]
    [clear_variable]
        name=tmp_unit
    [/clear_variable]
#enddef

#define RETURN_GUARDIAN ID GUARD_X GUARD_Y
    # Turns an existing unit into a return guardian
    [store_unit]
        [filter]
            id={ID}
        [/filter]
        variable=tmp_unit
    [/store_unit]
    [modify_ai]
        side=$tmp_unit.side
        action=add
        path=stage[main_loop].candidate_action[{ID}]
        [candidate_action]
            name=bca_retguard_{ID}
            id=bca_retguard_{ID}
            engine=lua
            sticky=yes
            unit_x=$tmp_unit.x
            unit_y=$tmp_unit.y
            evaluation="return (...):return_guardian_eval('{ID}', {GUARD_X}, {GUARD_Y})"
            execution="(...):return_guardian_exec('{ID}', {GUARD_X}, {GUARD_Y})"
        [/candidate_action]
    [/modify_ai]
    [clear_variable]
        name=tmp_unit
    [/clear_variable]
#enddef

#define STATIONED_GUARDIAN ID RADIUS STATION_X STATION_Y GUARD_X GUARD_Y
    # Turns an existing unit into a stationed guardian
    [store_unit]
        [filter]
            id={ID}
        [/filter]
        variable=tmp_unit
    [/store_unit]
    [modify_ai]
        side=$tmp_unit.side
        action=add
        path=stage[main_loop].candidate_action[{ID}]
        [candidate_action]
            name=bca_statguard_{ID}
            id=bca_statguard_{ID}
            engine=lua
            sticky=yes
            unit_x=$tmp_unit.x
            unit_y=$tmp_unit.y
            evaluation="return (...):stationed_guardian_eval('{ID}')"
            execution="(...):stationed_guardian_exec('{ID}', {RADIUS}, {STATION_X}, {STATION_Y}, {GUARD_X}, {GUARD_Y})"
        [/candidate_action]
    [/modify_ai]
    [clear_variable]
        name=tmp_unit
    [/clear_variable]
#enddef

#define HUNT_AND_REST_UNIT ID HUNT_X HUNT_Y HOME_X HOME_Y REST_TURNS
    # Turns an existing unit into a hunt_and_rest unit
    # HUNT_X/Y: range of x/y values of the wandering range, e.g. '1-30'
    # HOME_X/Y: coordinates of the location where to rest
    # REST_TURNS: number of turns to rest before going out for the next hunt
    [store_unit]
        [filter]
            id={ID}
        [/filter]
        variable=tmp_unit
    [/store_unit]
    [modify_ai]
        side=$tmp_unit.side
        action=add
        path=stage[main_loop].candidate_action[{ID}]
        [candidate_action]
            name=bca_huntrest_{ID}
            id=bca_huntrest_{ID}
            engine=lua
            sticky=yes
            unit_x=$tmp_unit.x
            unit_y=$tmp_unit.y
            evaluation="return (...):hunt_and_rest_eval('{ID}')"
            execution="(...):hunt_and_rest_exec('{ID}', '{HUNT_X}', '{HUNT_X}', {HOME_X}, {HOME_Y}, {REST_TURNS})"
        [/candidate_action]
    [/modify_ai]
    [clear_variable]
        name=tmp_unit
    [/clear_variable]
#enddef

